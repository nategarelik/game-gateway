import asyncio
import httpx
import uuid
import logging
import time

from src.agents.level_architect_agent import LevelArchitectAgent

# Configure logging for the script
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

MCP_SERVER_BASE_URL = "http://localhost:8000/api/v1" # Assuming MCP runs on port 8000 and v1 prefix
AGENT_ID = "level_architect_001"

async def run_scenario():
    logger.info("Starting Level Architect Agent integration scenario...")

    # 1. Instantiate LevelArchitectAgent
    # The mcp_server_url for the agent should point to the API base
    agent = LevelArchitectAgent(agent_id=AGENT_ID, mcp_server_url=MCP_SERVER_BASE_URL)
    logger.info(f"LevelArchitectAgent '{AGENT_ID}' instantiated.")

    # 2. Start and Register Agent
    try:
        logger.info(f"Attempting to start and register agent '{AGENT_ID}' with MCP at {MCP_SERVER_BASE_URL}...")
        await agent.start_and_register()
        # Add a small delay to ensure registration is processed if MCP is slow
        await asyncio.sleep(1) 
    except Exception as e:
        logger.error(f"Error during agent startup/registration: {e}", exc_info=True)
        await agent.shutdown()
        return

    # 3. Make an HTTP request to MCP's /request_action
    action_request_payload = {
        "target_agent_id": AGENT_ID,
        "action_type": "design_level",
        "parameters": {
            "prompt": "Design a small, spooky dungeon with traps and a secret room.",
            "theme": "haunted_catacombs",
            "constraints": ["must_be_completable_in_10_minutes", "no_dead_ends"],
            # task_id will be generated by MCP, but we need it for polling
        }
    }

    task_id_from_mcp = None
    async with httpx.AsyncClient() as client:
        try:
            logger.info(f"Sending /request_action to MCP for agent '{AGENT_ID}'...")
            response = await client.post(f"{MCP_SERVER_BASE_URL}/request_action", json=action_request_payload)
            response.raise_for_status()
            action_response_data = response.json()
            task_id_from_mcp = action_response_data.get("request_id") # This is the task_id for LangGraph
            logger.info(f"/request_action successful. MCP assigned Task ID: {task_id_from_mcp}")

        except httpx.HTTPStatusError as e:
            logger.error(f"Error requesting action from MCP: {e.response.status_code} - {e.response.text}", exc_info=True)
            await agent.shutdown()
            return
        except httpx.RequestError as e:
            logger.error(f"Request error while requesting action: {e}", exc_info=True)
            await agent.shutdown()
            return
        except Exception as e:
            logger.error(f"Unexpected error during /request_action: {e}", exc_info=True)
            await agent.shutdown()
            return

        if not task_id_from_mcp:
            logger.error("Failed to get task_id from MCP /request_action response.")
            await agent.shutdown()
            return

        # 4. Agent processes the task (this happens "in the background" conceptually)
        # For this test, we need to manually trigger the agent's task processing
        # as the MCP currently doesn't directly call the agent object.
        # The /request_action in MCP sets up a task in StateManager.
        # The agent would normally poll MCP for tasks or receive a direct call if architected differently.
        # Here, we simulate the agent receiving the task details.
        
        # The task_details for the agent's process_task method should include the task_id
        # that the MCP's StateManager is using.
        agent_task_details = {
            "task_id": task_id_from_mcp, # Use the task_id from MCP
            "parameters": {
                "prompt": action_request_payload["parameters"]["prompt"],
                "theme": action_request_payload["parameters"]["theme"],
                "constraints": action_request_payload["parameters"]["constraints"]
            },
            "current_event": {} # Empty current event for initial call
        }
        
        logger.info(f"Simulating agent '{AGENT_ID}' processing task '{task_id_from_mcp}'...")
        # This is an async call, so we await it.
        # The agent's process_task will post events back to MCP.
        processing_result = await agent.process_task(agent_task_details)
        logger.info(f"Agent task processing finished with result: {processing_result.get('status')}")


        # 5. Poll MCP's /task_status/{task_id}
        max_polls = 10
        poll_interval = 2  # seconds
        logger.info(f"Polling MCP for status of task '{task_id_from_mcp}'...")

        for i in range(max_polls):
            try:
                await asyncio.sleep(poll_interval)
                logger.info(f"Polling attempt {i+1}/{max_polls} for task '{task_id_from_mcp}'...")
                status_response = await client.get(f"{MCP_SERVER_BASE_URL}/task_status/{task_id_from_mcp}")
                status_response.raise_for_status()
                task_status_data = status_response.json()
                
                logger.info(f"Task Status for {task_id_from_mcp}:")
                logger.info(f"  Status: {task_status_data.get('status')}")
                logger.info(f"  Current Step: {task_status_data.get('current_step')}")
                logger.info(f"  History Count: {len(task_status_data.get('history', []))}")
                logger.info(f"  Agent Responses: {task_status_data.get('agent_responses')}")

                if task_status_data.get("status") in ["completed", "error", "failed", "nearing_completion"]:
                    logger.info(f"Task '{task_id_from_mcp}' reached a terminal state: {task_status_data.get('status')}")
                    if task_status_data.get("status") == "completed" or task_status_data.get("status") == "nearing_completion":
                         final_output = task_status_data.get("agent_responses", {}).get(AGENT_ID, {}).get("details", {}).get("level_data")
                         if final_output:
                             logger.info("Final Level Data (from agent event via StateManager):")
                             logger.info(str(final_output)[:500] + "..." if len(str(final_output)) > 500 else str(final_output))
                         else:
                             logger.info("Final level data not found in expected place in task state.")
                    break
            except httpx.HTTPStatusError as e:
                logger.error(f"Error polling task status: {e.response.status_code} - {e.response.text}")
                if e.response.status_code == 404:
                    logger.error(f"Task {task_id_from_mcp} not found on MCP. Did registration or task creation fail silently?")
                    break 
            except httpx.RequestError as e:
                logger.error(f"Request error while polling task status: {e}")
            except Exception as e:
                logger.error(f"Unexpected error during polling: {e}", exc_info=True)
                break
        else:
            logger.warning(f"Polling finished after {max_polls} attempts. Task may not have completed or reached a known terminal state.")

    logger.info("Scenario finished. Shutting down agent.")
    await agent.shutdown()

if __name__ == "__main__":
    # Ensure the MCP server (src.mcp_server.main:app) is running on localhost:8000
    # You can run it with: uvicorn src.mcp_server.main:app --reload
    logger.info("Make sure the MCP Server is running on http://localhost:8000")
    logger.info("Run: uvicorn src.mcp_server.main:app --reload --port 8000")
    asyncio.run(run_scenario())